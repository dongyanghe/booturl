
编程结果题：
> https://blog.csdn.net/qq_25186543/article/details/78456984
### 1、判断一个字符串中出现次数最多的字符，统计这个次数
```TypeScript
var str = 'asdfssaaasasasasaa'; 
var json = {}; 
for (var i = 0; i < str.length; i++) {
if(!json[str.charAt(i)]){
       json[str.charAt(i)] = 1;
    }else{
       json[str.charAt(i)]++;
    }
}; 
var iMax = 0; 
var iIndex = ''; 
for(var i in json){
 if(json[i]>iMax){
         iMax = json[i];
         iIndex = i;
    }
} 
console.log('出现次数最多的是:'+iIndex+'出现'+iMax+'次');
```
结果如下：出现次数最多的是:a出现9次

### 2、编写一个方法 去掉一个数组的重复元素
方法一：
```TypeScript
var arr = [0,2,3,4,4,0,2]; var obj = {}; var tmp = []; for(var i = 0 ;i< arr.length;i++){ if( !obj[arr[i]] ){
      obj[arr[i]] = 1;
      tmp.push(arr[i]);
   }
}
console.log(tmp);</pre>
```
结果如下： [0, 2, 3, 4]
 方法二：
```TypeScript
var arr = [2,3,4,4,5,2,3,6],
   arr2 = []; for(var i = 0;i< arr.length;i++){ if(arr2.indexOf(arr[i]) < 0){
        arr2.push(arr[i]);
    }
}
console.log(arr2);</pre>
```
结果为：[2, 3, 4, 5, 6]

 方法三：
```TypeScript
var arr = [2,3,4,4,5,2,3,6];
var arr2 = arr.filter(function(element,index,self){
return self.indexOf(element) === index;
});
console.log(arr2);
```
结果为：[2, 3, 4, 5, 6]
### 3、下面的代码将输出到控制台的是什么？，为什么？
```TypeScript

var  myObject  =  {

    foo:  "bar",

    func:  function()  {

        var  self  =  this;

        console.log("outer func:  this.foo = "  +  this.foo);

        console.log("outer func:  self.foo = "  +  self.foo);

        (function()  {

            console.log("inner func:  this.foo = "  +  this.foo);

            console.log("inner func:  self.foo = "  +  self.foo);

        }());

    }

};

myObject.func();

```
以上代码将输出到控制台：

```TypeScript
outer func:  this.foo  =  bar

outer func:  self.foo  =  bar

inner func:  this.foo  =  undefined

inner func:  self.foo  =  bar
```
在外部函数中，this和self都引用myObject，因此都可以正确地引用和访问foo。

但在内部函数中，这不再指向myObject。因此，this.foo在内部函数中是未定义的，而对局部变量self的引用仍然在范围内并且可以在那里访问。
### 手写一个js的深克隆

```TypeScript

//深拷贝函数
function deepCopy(p){
	var obj;
    //  类型判断搜索本文关键字：'类型判断'
	var str = Object.prototype.toString.call(p);
	if(str == '[object Array]'){
		obj = [];
		for (var i = 0; i < p.length; i++) {
			obj.push(arguments.callee(p[i]));  //回调自己
		}
	}else if(str == '[object Object]'){
		obj = {};
		for(var i in p){
			obj[i] = arguments.callee(p[i]);
		}
	}else{
		return p;
	}
	return obj;
}

```

## 39、for函数里面setTimeout异步问题
## 冒泡排序：
```TypeScript
var arr = [3,2,1];
for(var i = 0; i < arr.length - 1; i++) {
    for (var k = i+1;k< arr.length;k++) {
        var next = arr[k];
        if (now > next) {
            arr[k] = arr[i];
            arr[i] = next;
        }
    }
}
```
## 40、手写归并排序

<1>.长度为n(n>1),把该输入序列分成两个长度为n/2的子序列； 
<2>.对这两个子序列分别采用归并排序，直到长度n小于2； 
<3>.将两个排序好的子序列合并成一个最终的排序序列。

```TypeScript
function mergeSort(arr) { 
    var len = arr.length;
    if(len < 2) {
        return arr;
    } else {
        middle = Math.floor(len / 2);
        var left = arr.slice(0, middle);
        var right = arr.splice(middle);
        return merge(mergeSort(left), mergeSort(right));
    }

}

function merge(left, right) {
    var result = [];
    while(left.length && right.length) {
        left[0] > right[0] ? result.push(right.shift()): result.push(left.shift());
    }
    if(left.length) {
        result = result.concat(left);
    }
    if(right.length) {
        result = result.concat(right);
    }
    return result;
}
```
## 43、手写一个原生ajax

ajax：一种请求数据的方式，不需要刷新整个页面； 
ajax的技术核心是 XMLHttpRequest 对象； 
ajax 请求过程：创建 XMLHttpRequest 对象、连接服务器、发送请求、接收响应数据；

一个在stackoverflow的高分回答结合上面的代码，给出get和post的两种不同请求方法：

```
var ajax = {};
ajax.x = function () {
    if (typeof XMLHttpRequest !== 'undefined') {
        return new XMLHttpRequest();
    }
    var versions = [
    "MSXML2.XmlHttp.6.0",
    "MSXML2.XmlHttp.5.0",
    "MSXML2.XmlHttp.4.0",
    "MSXML2.XmlHttp.3.0",
    "MSXML2.XmlHttp.2.0",
    "Microsoft.XmlHttp"
    ];

    var xhr;
    for (var i = 0; i < versions.length; i++) {
        try {
            xhr = new ActiveXObject(versions[i]);
            break;
        } catch (e) {
        }
    }
    return xhr;
};

ajax.send = function (url, method, data, success,fail,async) {
    if (async === undefined) {
        async = true;
    }
    var x = ajax.x();
    x.open(method, url, async);
    x.onreadystatechange = function () {
        if (x.readyState == 4) {
            var status = x.status;
            if (status >= 200 && status < 300) {
                success && success(x.responseText,x.responseXML)
            } else {
                fail && fail(status);
            }

        }
    };
    if (method == 'POST') {
        x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
    }
    x.send(data)
};

ajax.get = function (url, data, callback, fail, async) {
    var query = [];
    for (var key in data) {
        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
    }
    ajax.send(url + (query.length ? '?' + query.join('&') : ''), 'GET', null, success, fail, async)
};

ajax.post = function (url, data, callback, fail, async) {
    var query = [];
    for (var key in data) {
        query.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));
    }
    ajax.send(url,'POST', query.join('&'), success, fail, async)
};
```

使用方法：GET

```
ajax.get('/test.php', {foo: 'bar'}, function(response,xml) {
    //success
},
function(status){
    //fail
});
```

POST

```
ajax.post('/test.php', {foo: 'bar'}, function(response,xml) {
    //succcess

},function(status){
    //fail

});
```

## 2、手写单链表查找倒数第k个节点

1、为了找出倒数第k个元素，最容易想到的办法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下来遍历一次就可以得到结果。但是该方法存在一个问题，即需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 
这种思路的时间复杂度是O(n)，但需要遍历链表两次。

2、如果我们在遍历时维持两个指针，第一个指针从链表的头指针开始遍历，在第k-1步之前，第二个指针保持不动；在第k-1步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。这种思路只需要遍历链表一次。对于很长的链表，只需要把每个结点从硬盘导入到内存一次。因此这一方法的时间效率前面的方法要高。

```TypeScript
class Node{
    Node next=null;
    int data;
    public Node(int data){
        this.data=data;
    }
}
public class MyLinkedList {

    Node head=null;//链表头的引用
    public Node findElem(Node head,int k){
        if(k<1||k>this.length()){
            return null;
        }
        Node p1=head;
        Node p2=head;
        for(int i=0;i<k;i++)
            p1=p1.next;
        while(p1!=null){
            p1=p1.next;
            p2=p2.next;
        }
        return p2;
    }
    public static void main(String[] args) {

        MyLinkedList list=new MyLinkedList();
        list.addNode(1);
        list.addNode(2);
        list.addNode(3);
        list.addNode(4);
        list.addNode(5);
        MyLinkedList p=new MyLinkedList();
        p.head=list.findElem(list.head, 3);
        p.printList();

    }

}
```
**JSONP的客户端具体实现：** 
1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。 
远程服务器remoteserver.com根目录下有个remote.js文件代码如下：

```TypeScript
alert('我是远程文件');
```

本地服务器localserver.com下有个jsonp.html页面代码如下：

```TypeScript
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>

</body>
</html>
```

毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。

2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。

jsonp.html页面代码如下：

```TypeScript
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>

</body>
</html>
```

remote.js文件代码如下：

```TypeScript
localHandler({"result":"我是远程js带来的数据"});
```

运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。 
很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。

3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端 “我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。

看jsonp.html页面的代码：

```TypeScript
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script); 
    </script>
</head>
<body>
</body>
</html>
```

这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。 
我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。 
OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html

（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 
HTML 代码

```TypeScript
flightHandler({
    "code": "CA1998",
    "price": 1780,
    "tickets": 5
});
```

我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！

4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。

**jQuery如何实现jsonp调用？**

```TypeScript
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
     <title>Untitled Page</title>
      <script type="text/javascript" src=jquery.min.js"></script>
      <script type="text/javascript">
     jQuery(document).ready(function(){ 
        $.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     </script>
     </head>
  <body>
  </body>
</html>
```

**这里针对ajax与jsonp的异同再做一些补充说明：**

1、ajax和jsonp这两种技术在调用方式上”看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装。

2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。

3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。

4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。

总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！

### 6、考虑下面的两个函数。他们都会返回同样的值吗？为什么或者为什么不？
```TypeScript

function  foo1()

{

  return  {

      bar:  "hello"

  };

}

function  foo2()

{

  return

  {

      bar:  "hello"

  };

}

```

令人惊讶的是，这两个函数不会返回相同的结果。而是：
```TypeScript

console.log("foo1 returns:");

console.log(foo1());

console.log("foo2 returns:");

console.log(foo2());
```
会产生：
```TypeScript
foo1 returns:

Object  {bar:  "hello"}

foo2 returns:

undefined
```

这不仅令人惊讶，而且特别令人烦恼的是，foo2()返回未定义而没有引发任何错误。

原因与JavaScript中分号在技术上是可选的事实有关（尽管忽略它们通常是非常糟糕的形式）。因此，在foo2()中遇到包含return语句的行（没有其他内容）时，*会在return语句之后立即自动插入分号。*

由于代码的其余部分是完全有效的，即使它没有被调用或做任何事情（它只是一个未使用的代码块，它定义了一个属性栏，它等于字符串“hello”），所以不会抛出任何错误。

这种行为也被认为是遵循了在JavaScript中将一行开头大括号放在行尾的约定，而不是在新行的开头。如此处所示，这不仅仅是JavaScript中的一种风格偏好。

### 7、什么是NaN？它的类型是什么？如何可靠地测试一个值是否等于NaN？

NaN属性表示“不是数字”的值。这个特殊值是由于一个操作数是非数字的（例如“abc”/ 4）或者因为操作的结果是非数字而无法执行的。

虽然这看起来很简单，但NaN有一些令人惊讶的特征，如果人们没有意识到这些特征，就会导致bug。

一方面，虽然NaN的意思是“不是数字”，但它的类型是，数字：
```TypeScript
console.log(typeof NaN  ===  "number");  // logs "true"
```

此外，NaN相比任何事情 – 甚至本身！ – 是false：

```TypeScript
console.log(NaN  ===  NaN);  // logs "false"

```

测试数字是否等于NaN的半可靠方法是使用内置函数isNaN()，但即使使用[isNaN()也不是一个好的解决方案。](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN#Confusing_special-case_behavior).

一个更好的解决方案要么是使用value！==值，如果该值等于NaN，那么只会生成true。另外，ES6提供了一个新的[Number.isNaN()函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN) ，它与旧的全局isNaN()函数不同，也更加可靠。

### 8、下面的代码输出什么？解释你的答案。
```TypeScript

console.log(0.1  +  0.2);

console.log(0.1  +  0.2  ==  0.3);
```

对这个问题的一个有教养的回答是：“你不能确定。它可能打印出0.3和true，或者可能不打印。 JavaScript中的数字全部用浮点精度处理，因此可能不会总是产生预期的结果。“

上面提供的示例是演示此问题的经典案例。令人惊讶的是，它会打印出来：

```TypeScript

0.30000000000000004

false
```

一个典型的解决方案是比较两个数字与特殊常数Number.EPSILON之间的绝对差值：
```TypeScript

function  areTheNumbersAlmostEqual(num1,  num2)  {

    return  Math.abs(  num1  -  num2  )  <  Number.EPSILON;

}

console.log(areTheNumbersAlmostEqual(0.1  +  0.2,  0.3));
```

讨论写函数的可能方法isInteger（x），它确定x是否是一个整数。

这听起来很平凡，事实上，ECMAscript 6为此正好引入了一个新的Number.isInteger()函数，这是微不足道的。但是，在ECMAScript 6之前，这有点复杂，因为没有提供与Number.isInteger()方法等价的方法。

问题在于，在ECMAScript规范中，整数只在概念上存在;即数值始终作为浮点值存储。

考虑到这一点，最简单，最清洁的ECMAScript-6之前的解决方案（即使将非数字值（例如字符串或空值）传递给该函数，该解决方案也具有足够的可靠性以返回false）将成为以下用法按位异或运算符：
```TypeScript

function  isInteger(x)  {  return  (x  ^  0)  ===  x;  }
```

下面的解决方案也可以工作，尽管不如上面那样高雅
```TypeScript
function  isInteger(x)  {  return  Math.round(x)  ===  x;  }
```

请注意，在上面的实现中Math.ceil()或Math.floor()可以同样使用（而不是Math.round()）。

或者：
```TypeScript

function  isInteger(x)  {  return  (typeof  x  ===  'number')  &&  (x  %  1  ===  0);  }
```

一个相当常见的不正确的解决方案如下：
```TypeScript
function  isInteger(x)  {  return  parseInt(x,  10)  ===  x;  }
```

虽然这个基于parseInt的方法对许多x值很有效，但一旦x变得相当大，它将无法正常工作。问题是parseInt()在解析数字之前将其第一个参数强制转换为字符串。因此，一旦数字变得足够大，其字符串表示将以指数形式呈现（例如1e + 21）。因此，parseInt()将尝试解析1e + 21，但是当它到达e字符时将停止解析，因此将返回值1.观察：
```TypeScript
String(1000000000000000000000)

'1e+21'

 parseInt(1000000000000000000000,  10)

parseInt(1000000000000000000000,  10)  ===  1000000000000000000000

```
### 9、执行下面的代码时，按什么顺序将数字1-4记录到控制台？为什么？
```TypeScript

(function()  {

    console.log(1);

    setTimeout(function(){console.log(2)},  1000);

    setTimeout(function(){console.log(3)},  0);

    console.log(4);

})();
```

这些值将按以下顺序记录：
```TypeScript
1

4

3

2
```

我们先来解释一下这些可能更为明显的部分：

*   首先显示1和4，因为它们是通过简单调用console.log()而没有任何延迟记录的
*   在3之后显示，因为在延迟1000毫秒（即1秒）之后记录2，而在0毫秒的延迟之后记录3。

好的。但是，如果在延迟0毫秒后记录3，这是否意味着它正在被立即记录？而且，如果是这样，不应该在4之前记录它，因为4是由后面的代码行记录的吗？

答案与正确理解[JavaScript事件和时间有关。 ](http://javascript.info/tutorial/events-and-timing-depth).

浏览器有一个事件循环，它检查事件队列并处理未决事件。例如，如果在浏览器繁忙时（例如，处理onclick）在后台发生事件（例如脚本onload事件），则该事件被附加到队列中。当onclick处理程序完成时，将检查队列并处理该事件（例如，执行onload脚本）。

同样，如果浏览器繁忙，setTimeout()也会将其引用函数的执行放入事件队列中。

当值为零作为setTimeout()的第二个参数传递时，它将尝试“尽快”执行指定的函数。具体来说，函数的执行放置在事件队列中，以在下一个计时器滴答时发生。但请注意，这不是直接的;该功能不会执行，直到下一个滴答声。这就是为什么在上面的例子中，调用console.log（4）发生在调用console.log（3）之前（因为调用console.log（3）是通过setTimeout调用的，所以稍微延迟了一点）。

### 10、编写一个简单的函数（少于160个字符），返回一个布尔值，指示字符串是否是[palindrome](http://www.palindromelist.net/)。

如果str是回文，以下一行函数将返回true;否则，它返回false。
```TypeScript

function  isPalindrome(str)  {

  str  =  str.replace(/\W/g,  '').toLowerCase();

  return  (str  ==  str.split('').reverse().join(''));

}
```

例如：
```TypeScript

console.log(isPalindrome("level")); // logs 'true'

console.log(isPalindrome("levels"));                  // logs 'false'

console.log(isPalindrome("A car, a man, a maraca"));  // logs 'true'
```
### 11、写一个sum方法，当使用下面的语法调用时它将正常工作。
```TypeScript

console.log(sum(2,3)); // Outputs 5

console.log(sum(2)(3));  // Outputs 5
```

有（至少）两种方法可以做到这一点：

**METHOD 1**

```TypeScript

function  sum(x)  {

  if  (arguments.length  ==  2)  {

    return  arguments[0]  +  arguments[1];

  }  else  {

    return  function(y)  {  return  x  +  y;  };

  }

}
```
在JavaScript中，函数提供对参数对象的访问，该对象提供对传递给函数的实际参数的访问。这使我们能够使用length属性在运行时确定传递给函数的参数的数量

如果传递两个参数，我们只需将它们相加并返回。

否则，我们假设它是以sum（2）（3）的形式被调用的，所以我们返回一个匿名函数，它将传递给sum()（在本例中为2）的参数和传递给匿名函数的参数这种情况3）。

**METHOD 2**

```TypeScript

function  sum(x,  y)  {

  if  (y  !==  undefined)  {

    return  x  +  y;

  }  else  {

    return  function(y)  {  return  x  +  y;  };

  }

}
```
当函数被调用时，JavaScript不需要参数的数量来匹配函数定义中参数的数量。如果传递的参数数量超过了函数定义中参数的数量，则超出的参数将被忽略。另一方面，如果传递的参数数量少于函数定义中的参数数量，则在函数内引用时，缺少的参数将具有未定义的值。因此，在上面的例子中，通过简单地检查第二个参数是否未定义，我们可以确定函数被调用的方式并相应地继续。

### 12、考虑下面的代码片段

```TypeScript

for  (var  i  =  0;  i  <  5;  i++)  {

  var  btn  =  document.createElement('button');

  btn.appendChild(document.createTextNode('Button '  +  i));

  btn.addEventListener('click',  function(){  console.log(i);  });

  document.body.appendChild(btn);

}
```

(a) 当用户点击“按钮4”时，什么被记录到控制台？为什么？

(b) 提供一个或多个可按预期工作的替代实现。

答：

(a) 无论用户点击哪个按钮，数字5将始终记录到控制台。这是因为，在调用onclick方法（对于任何按钮）时，for循环已经完成，并且变量i已经具有值5.（如果受访者知道足够的话就可以获得奖励点数关于执行上下文，变量对象，激活对象和内部“范围”属性如何影响闭包行为。）

(b) 使这项工作的关键是通过将它传递给新创建的函数对象来捕获每次通过for循环的i的值。以下是四种可能的方法来实现这一点：

```TypeScript

for  (var  i  =  0;  i  <  5;  i++)  {

  var  btn  =  document.createElement('button');

  btn.appendChild(document.createTextNode('Button '  +  i));

  btn.addEventListener('click',  (function(i)  {

    return  function()  {  console.log(i);  };

  })(i));

  document.body.appendChild(btn);

}

```

或者，您可以将新的匿名函数中的整个调用包装为btn.addEventListener：

```TypeScript

for  (var  i  =  0;  i  <  5;  i++)  {

  var  btn  =  document.createElement('button');

  btn.appendChild(document.createTextNode('Button '  +  i));

  (function  (i)  {

    btn.addEventListener('click',  function()  {  console.log(i);  });

  })(i);

  document.body.appendChild(btn);

}

```

或者，我们可以通过调用数组对象的原生forEach方法来替换for循环：

```TypeScript
['a',  'b',  'c',  'd',  'e'].forEach(function  (value,  i)  {

  var  btn  =  document.createElement('button');

  btn.appendChild(document.createTextNode('Button '  +  i));

  btn.addEventListener('click',  function()  {  console.log(i);  });

  document.body.appendChild(btn);

});

```

最后，最简单的解决方案，如果你在ES6 / ES2015上下文中，就是使用let i而不是var i：

```TypeScript

for  (let  i  =  0;  i  <  5;  i++)  {

  var  btn  =  document.createElement('button');

  btn.appendChild(document.createTextNode('Button '  +  i));

  btn.addEventListener('click',  function(){  console.log(i);  });

  document.body.appendChild(btn);

}

```

### 13、假设d是范围内的“空”对象：

```TypeScript

| 


var  d  =  {};

```

…使用下面的代码完成了什么？

```TypeScript



[  'zebra',  'horse'  ].forEach(function(k)  {

    d[k]  =  undefined;

});

```

上面显示的代码片段在对象d上设置了两个属性。理想情况下，对具有未设置键的JavaScript对象执行的查找评估为未定义。但是运行这段代码会将这些属性标记为对象的“自己的属性”。

这是确保对象具有一组给定属性的有用策略。将该对象传递给Object.keys将返回一个包含这些设置键的数组（即使它们的值未定义）。

### 14、下面的代码将输出到控制台，为什么？

```TypeScript

var  arr1  =  "john".split('');

var  arr2  =  arr1.reverse();

var  arr3  =  "jones".split('');

arr2.push(arr3);

console.log("array 1: length="  +  arr1.length  +  " last="  +  arr1.slice(-1));

console.log("array 2: length="  +  arr2.length  +  " last="  +  arr2.slice(-1));

```

记录的输出将是：

```TypeScript
"array 1: length=5 last=j,o,n,e,s"

"array 2: length=5 last=j,o,n,e,s"

```

arr1和arr2是相同的（即[‘n’，’h’，’o’，’j’，[‘j’，’o’，’n’，’e’，’s’]]）上述代码由于以下原因而被执行：

*   调用数组对象的reverse()方法不仅以相反的顺序返回数组，它还颠倒了数组本身的顺序（即在这种情况下，arr1）。
*   reverse()方法返回对数组本身的引用（即，在这种情况下为arr1）。因此，arr2仅仅是对arr1的引用（而不是副本）。因此，当对arr2做任何事情时（即，当我们调用arr2.push（arr3）;）时，arr1也会受到影响，因为arr1和arr2只是对同一个对象的引用。

这里有几个观点可以让人们回答这个问题：

*   将数组传递给另一个数组的push()方法会将整个数组作为单个元素推入数组的末尾。结果，声明arr2.push（arr3）;将arr3作为一个整体添加到arr2的末尾（即，它不连接两个数组，这就是concat()方法的用途）。
*   像Python一样，JavaScript在调用像slice()这样的数组方法时，会承认负面下标，以此作为在数组末尾引用元素的方式;例如，下标-1表示数组中的最后一个元素，依此类推。

### 15、下面的代码将输出到控制台，为什么？

```TypeScript

console.log(1  +  "2"  +  "2");

console.log(1  +  +"2"  +  "2");

console.log(1  +  -"1"  +  "2");

console.log(+"1"  +  "1"  +  "2");

console.log(  "A"  -  "B"  +  "2");

console.log(  "A"  -  "B"  +  2);

```

以上代码将输出到控制台：

```TypeScript

"122"

"32"

"02"

"112"

"NaN2"

NaN

```

这是为什么…

这里的基本问题是JavaScript（ECMAScript）是一种松散类型的语言，它对值执行自动类型转换以适应正在执行的操作。让我们来看看这是如何与上面的每个例子进行比较。

示例1：1 +“2”+“2”输出：“122”说明：第一个操作在1 +“2”中执行。由于其中一个操作数（“2”）是一个字符串，所以JavaScript假定需要执行字符串连接，因此将1的类型转换为“1”，1 +“2”转换为“12”。然后，“12”+“2”产生“122”。

示例2：1 + +“2”+“2”输出：“32”说明：根据操作顺序，要执行的第一个操作是+“2”（第一个“2”之前的额外+被视为一个一元运算符）。因此，JavaScript将“2”的类型转换为数字，然后将一元+符号应用于它（即将其视为正数）。结果，下一个操作现在是1 + 2，当然这会产生3.但是，我们有一个数字和一个字符串之间的操作（即3和“2”），所以JavaScript再次转换数值赋给一个字符串并执行字符串连接，产生“32”。

示例3：1 + – “1”+“2”输出：“02”说明：这里的解释与前面的示例相同，只是一元运算符是 – 而不是+。因此，“1”变为1，然后在应用 – 时将其变为-1，然后将其加1到产生0，然后转换为字符串并与最终的“2”操作数连接，产生“02”。

示例4：+“1”+“1”+“2”输出：“112”说明：尽管第一个“1”操作数是基于其前面的一元+运算符的数值类型转换的，当它与第二个“1”操作数连接在一起时返回一个字符串，然后与最终的“2”操作数连接，产生字符串“112”。

示例5：“A” – “B”+“2”输出：“NaN2”说明：由于 – 运算符不能应用于字符串，并且既不能将“A”也不能将“B”转换为数值， “ – ”B“产生NaN，然后与字符串”2“串联产生”NaN2“。

例6：“A” – “B”+2输出：NaN说明：在前面的例子中，“A” – “B”产生NaN。但是任何运算符应用于NaN和其他数字操作数仍然会产生NaN。

### 16、如果数组列表太大，以下递归代码将导致堆栈溢出。你如何解决这个问题，仍然保留递归模式？

```TypeScript

var  list  =  readHugeList();

var  nextListItem  =  function()  {

    var  item  =  list.pop();

    if  (item)  {

        // process the list item...

        nextListItem();

    }

};

```

通过修改nextListItem函数可以避免潜在的堆栈溢出，如下所示：

```TypeScript

var  list  =  readHugeList();

var  nextListItem  =  function()  {

    var  item  =  list.pop();

    if  (item)  {

        // process the list item...

        setTimeout(  nextListItem,  0);

    }

};

```

堆栈溢出被消除，因为事件循环处理递归，而不是调用堆栈。当nextListItem运行时，如果item不为null，则将超时函数（nextListItem）推送到事件队列，并且函数退出，从而使调用堆栈清零。当事件队列运行超时事件时，将处理下一个项目，并设置一个计时器以再次调用nextListItem。因此，该方法从头到尾不经过直接递归调用即可处理，因此调用堆栈保持清晰，无论迭代次数如何。

### 17、什么是JavaScript中的“闭包”？举一个例子。

闭包是一个内部函数，它可以访问外部（封闭）函数的作用域链中的变量。闭包可以访问三个范围内的变量;具体来说：（1）变量在其自己的范围内，（2）封闭函数范围内的变量，以及（3）全局变量。

这里是一个例子：

```TypeScript

var  globalVar  =  "xyz";

(function  outerFunc(outerArg)  {

    var  outerVar  =  'a';

    (function  innerFunc(innerArg)  {

    var  innerVar  =  'b';

    console.log(

        "outerArg = "  +  outerArg  +  "\n"  +

        "innerArg = "  +  innerArg  +  "\n"  +

        "outerVar = "  +  outerVar  +  "\n"  +

        "innerVar = "  +  innerVar  +  "\n"  +

        "globalVar = "  +  globalVar);

    })(456);

})(123);

```

在上面的例子中，innerFunc，outerFunc和全局名称空间的变量都在innerFunc的范围内。上面的代码将产生以下输出：

```TypeScript

outerArg  =  123

innerArg  =  456

outerVar  =  a

innerVar  =  b

globalVar  =  xyz

```

### 18、以下代码的输出是什么：

```TypeScript

for  (var  i  =  0;  i  <  5;  i++)  {

    setTimeout(function()  {  console.log(i);  },  i *  1000  );

}

```

解释你的答案。如何在这里使用闭包？

显示的代码示例不会显示值0,1,2,3和4，这可能是预期的;而是显示5,5,5,5。

这是因为循环内执行的每个函数将在整个循环完成后执行，因此所有函数都会引用存储在i中的最后一个值，即5。

通过为每次迭代创建一个[唯一的作用域](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) ，可以使用闭包来防止这个问题，并将该变量的每个唯一值存储在其作用域中，如下所示：

```TypeScript
for  (var  i  =  0;  i  <  5;  i++)  {

    (function(x)  {

        setTimeout(function()  {  console.log(x);  },  x *  1000  );

    })(i);

}

```

这会产生将0,1,2,3和4记录到控制台的可能结果。

在[ES2015上下文中](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Creating_closures_in_loops_A_common_mistake)，您可以在原始代码中简单地使用let而不是var：

```TypeScript

for  (let  i  =  0;  i  <  5;  i++)  {

    setTimeout(function()  {  console.log(i);  },  i *  1000  );

}

```

### 19、以下几行代码输出到控制台？

```TypeScript

console.log("0```| 1 = "+(0 ```|  1));

console.log("1```| 2 = "+(1 ```|  2));

console.log("0 && 1 = "+(0  &&  1));

console.log("1 && 2 = "+(1  &&  2));

```

解释你的答案。

该代码将输出以下四行：

```TypeScript

0 ```|  1  =  1

1 ```|  2  =  1

0  &&  1  =  0

1  &&  2  =  2

```

在JavaScript中，都是||和&&是逻辑运算符，当从左向右计算时返回第一个完全确定的“逻辑值”。

或（||）运算符。在形式为X```| Y的表达式中，首先计算X并将其解释为布尔值。如果此布尔值为真，则返回true（1），并且不计算Y，因为“或”条件已经满足。但是，如果此布尔值为“假”，我们仍然不知道X```| Y是真还是假，直到我们评估Y，并将其解释为布尔值。

因此，0```| 1评估为真（1），正如1```| 2。

和（&&）运算符。在X && Y形式的表达式中，首先评估X并将其解释为布尔值。如果此布尔值为false，则返回false（0）并且不评估Y，因为“and”条件已失败。但是，如果这个布尔值为“真”，我们仍然不知道X && Y是真还是假，直到我们评估Y，并将其解释为布尔值。

然而，&&运算符的有趣之处在于，当表达式评估为“真”时，则返回表达式本身。这很好，因为它在逻辑表达式中被视为“真”，但也可以用于在您关心时返回该值。这解释了为什么，有点令人惊讶的是，1 && 2返回2（而你可能会期望它返回true或1）。

### 20 、下面的代码执行时输出是什么？说明。

```TypeScript

console.log(false  ==  '0')

console.log(false  ===  '0')

```

该代码将输出：

```TypeScript

true

false

```

在JavaScript中，有两套相等运算符。三重相等运算符===的行为与任何传统的相等运算符相同：如果两侧的两个表达式具有相同的类型和相同的值，则计算结果为true。然而，双等号运算符在比较它们之前试图强制这些值。因此，通常使用===而不是==。对于！== vs！=也是如此。
## 使用js，返回1到400所有自然数中一共出现过多少次“1”，如1到21一共出现过13次“1”
解题思路
由于前面的前端东西问的比较多而且杂，导致做到这里时没多少时间了，只好随便写了个，方法很简单，就是将1到400所有的自然数转换为类似001，012，311这样的长度的字符串，然后利用for循环求得1的个数即可，代码如下：



代码

js代码，它笔试提供的编译环境是nodejs，其实差不多，看看就行



//输入数字和期望的长度，转化为对应长度字符串，用0补足
function exp(num,length){
    var numstr = num.toString();
    var m = numstr.length;
    if(numstr.length >= length){
        return numstr;
    }
    for(var i = 0;i<length-m;i++){
        numstr="0" + numstr;
    }
    return numstr;
}

//调用函数exp，使用for循环一个个比较
var n;
var result = 0;
for(n=1;n<=400;n++){
    var numstr = exp(n,3);
    for(s=0;s<numstr.length;s++){
        if(numstr[s] == 1){
            result += 1; 
        }
    }
}
console.log(result)

---------------------

本文来自 GodknowsZZO 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qq_26993921/article/details/79677693?utm_source=copy 
### 21、以下代码的输出是什么？解释你的答案。

```TypeScript
var  a={},

    b={key:'b'},

    c={key:'c'};

a[b]=123;

a[c]=456;

console.log(a[b]);

```

此代码的输出将是456（不是123）。

原因如下：设置对象属性时，JavaScript会隐式地将参数值串联起来。在这种情况下，由于b和c都是对象，它们都将被转换为“[object Object]”。因此，a [b]和a [c]都等价于[“[object Object]”]，并且可以互换使用。因此，设置或引用[c]与设置或引用[b]完全相同。

### 22、以下代码将输出到控制台中.

```TypeScript

console.log((function  f(n){return  ((n  >  1)  ?  n *  f(n-1)  :  n)})(10));

```

该代码将输出10阶乘的值（即10！或3,628,800）。

原因如下：

命名函数f()以递归方式调用自身，直到它调用f（1），它简单地返回1.因此，这就是它的作用：

```TypeScript

f(1):  returns  n,  which is  1

f(2):  returns  2  *  f(1),  which is  2

f(3):  returns  3  *  f(2),  which is  6

f(4):  returns  4  *  f(3),  which is  24

f(5):  returns  5  *  f(4),  which is  120

f(6):  returns  6  *  f(5),  which is  720

f(7):  returns  7  *  f(6),  which is  5040

f(8):  returns  8  *  f(7),  which is  40320

f(9):  returns  9  *  f(8),  which is  362880

f(10):  returns  10  *  f(9),  which is  3628800

```

### 23 、考虑下面的代码片段。控制台的输出是什么，为什么？

```TypeScript

(function(x)  {

    return  (function(y)  {

        console.log(x);

    })(2)

})(1);

```

输出将为1，即使x的值从未在内部函数中设置。原因如下：

正如我们的[JavaScript招聘指南](https://www.toptal.com/javascript#hiring-guide)中所解释的，闭包是一个函数，以及创建闭包时在范围内的所有变量或函数。在JavaScript中，闭包被实现为“内部函数”;即在另一功能的主体内定义的功能。闭包的一个重要特征是内部函数仍然可以访问外部函数的变量。

因此，在这个例子中，因为x没有在内部函数中定义，所以在外部函数的作用域中搜索一个定义的变量x，该变量的值为1。

### 24、以下代码将输出到控制台以及为什么

```TypeScript

var  hero  =  {

    _name:  'John Doe',

    getSecretIdentity:  function  (){

        return  this._name;

    }

};

var  stoleSecretIdentity  =  hero.getSecretIdentity;

console.log(stoleSecretIdentity());

console.log(hero.getSecretIdentity());

```

这段代码有什么问题，以及如何解决这个问题。

该代码将输出：

```TypeScript

undefined

John Doe

```

第一个console.log打印未定义，因为我们从hero对象中提取方法，所以stoleSecretIdentity()在_name属性不存在的全局上下文（即窗口对象）中被调用。

修复stoleSecretIdentity()函数的一种方法如下：

```TypeScript
var  stoleSecretIdentity  =  hero.getSecretIdentity.bind(hero);

```

### 25、创建一个函数，给定页面上的DOM元素，将访问元素本身及其所有后代（*不仅仅是它的直接子元素*）。对于每个访问的元素，函数应该将该元素传递给提供的回调函数。

该函数的参数应该是：

*   一个 DOM 元素
*   一个回调函数（以DOM元素作为参数）

访问树中的所有元素（DOM）是[经典的深度优先搜索算法][Depth-First-Search algorithm](https://en.wikipedia.org/wiki/Depth-first_search)应用程序。以下是一个示例解决方案：

```TypeScript

function  Traverse(p_element,p_callback)  {

 p_callback(p_element);

 var  list  =  p_element.children;

 for  (var  i  =  0;  i  <  list.length;  i++)  {

 Traverse(list[i],p_callback);  // recursive call

 }

}

```

### 27、在JavaScript中测试您的这些知识：以下代码的输出是什么？

```TypeScript

var  length  =  10;

function  fn()  {

    console.log(this.length);

}

var  obj  =  {

  length:  5,

  method:  function(fn)  {

    fn();

    arguments[0]();

  }

};

obj.method(fn,  1);

```

输出：

```TypeScript

10

2

```

为什么不是10和5？

首先，由于fn作为函数方法的参数传递，函数fn的作用域（this）是窗口。 var length = 10;在窗口级别声明。它也可以作为window.length或length或this.length来访问（当这个===窗口时）。

方法绑定到Object obj，obj.method用参数fn和1调用。虽然方法只接受一个参数，但调用它时已经传递了两个参数;第一个是函数回调，其他只是一个数字。

当在内部方法中调用fn()时，该函数在全局级别作为参数传递，this.length将有权访问在Object obj中定义的var length = 10（全局声明）而不是length = 5。

现在，我们知道我们可以使用arguments []数组访问JavaScript函数中的任意数量的参数。

因此arguments0只不过是调用fn()。在fn里面，这个函数的作用域成为参数数组，并且记录参数[]的长度将返回2。

因此输出将如上所述。

### 28、考虑下面的代码。输出是什么，为什么？

```TypeScript

(function  ()  {

    try  {

        throw  new  Error();

    }  catch  (x)  {

        var  x  =  1,  y  =  2;

        console.log(x);

    }

    console.log(x);

    console.log(y);

})();

```

```TypeScript

1

undefined

2

```

var语句被挂起（没有它们的值初始化）到它所属的全局或函数作用域的顶部，即使它位于with或catch块内。但是，错误的标识符只在catch块内部可见。它相当于：

```TypeScript

(function  ()  {

    var  x,  y;  // outer and hoisted

    try  {

        throw  new  Error();

    }  catch  (x  /* inner */)  {

        x  =  1;  // inner x, not the outer one

        y  =  2;  // there is only one y, which is in the outer scope

        console.log(x  /* inner */);

    }

    console.log(x);

    console.log(y);

})();

```

### 29、这段代码的输出是什么？

```TypeScript

var  x  =  21;

var  girl  =  function  ()  {

    console.log(x);

    var  x  =  20;

};

girl  ();

```

21，也不是20，结果是‘undefined’的

这是因为JavaScript初始化没有被挂起。

（为什么它不显示21的全局值？原因是当函数执行时，它检查是否存在本地x变量但尚未声明它，因此它不会查找全局变量。 ）

### 30、你如何克隆一个对象？

```TypeScript

var  obj  =  {a:  1  ,b:  2}

var  objclone  =  Object.assign({},obj);

```

现在objclone的值是{a：1，b：2}，但指向与obj不同的对象。

但请注意潜在的缺陷：Object.assign()只会执行浅拷贝，而不是深拷贝。这意味着嵌套的对象不会被复制。他们仍然引用与原始相同的嵌套对象：
```TypeScript
let obj  =  {

    a:  1,

    b:  2,

    c:  {

        age:  30

    }

};

var  objclone  =  Object.assign({},obj);

console.log('objclone: ',  objclone);

obj.c.age  =  45;

console.log('After Change - obj: ',  obj); // 45 - This also changes

console.log('After Change - objclone: ',  objclone);  // 45

for  (let  i  =  0;  i  <  5;  i++)  {

  setTimeout(function()  {  console.log(i);  },  i *  1000  );

}

```
### 31、此代码将打印什么？

```TypeScript

for  (let  i  =  0;  i  <  5;  i++)  {

    setTimeout(function()  {  console.log(i);  },  i *  1000  );

}

```

它会打印0 1 2 3 4，因为我们在这里使用let而不是var。变量i只能在for循环的块范围中看到。

### 32、以下几行输出什么，为什么？

```TypeScript

console.log(1  <  2  <  3);

console.log(3  >  2  >  1);

```

第一条语句返回true，如预期的那样。

第二个返回false是因为引擎如何针对<和>的操作符关联性工作。它比较从左到右，所以3> 2> 1 JavaScript翻译为true> 1\. true具有值1，因此它比较1> 1，这是错误的。

### 33、如何在数组的开头添加元素？最后如何添加一个？

```TypeScript

var  myArray  =  ['a',  'b',  'c',  'd'];

myArray.push('end');

myArray.unshift('start');

console.log(myArray);  // ["start", "a", "b", "c", "d", "end"]

```

使用ES6，可以使用扩展运算符：

```TypeScript

myArray  =  ['start',  ...myArray];

myArray  =  [...myArray,  'end'];

```

或者，简而言之：

```TypeScript

myArray  =  ['start',  ...myArray,  'end'];

```

### 34、想象一下你有这样的代码:

```TypeScript

var  a  =  [1,  2,  3];

```

a）这会导致崩溃吗？

```TypeScript

a[10]  =  99;

```

b）这个输出是什么？

```TypeScript

console.log(a[6]);

```

a）它不会崩溃。 JavaScript引擎将使阵列插槽3至9成为“空插槽”。

b）在这里，a [6]将输出未定义的值，但时隙仍为空，而不是未定义的。在某些情况下，这可能是一个重要的细微差别。例如，使用map()时，map()的输出中的空插槽将保持为空，但未定义的插槽将使用传递给它的函数重映射：

```TypeScript

var  b  =  [undefined];

b[2]  =  1;

console.log(b); // (3) [undefined, empty × 1, 1]

console.log(b.map(e  =>  7));  // (3) [7,         empty × 1, 7]

```

### 35、typeof undefined == typeof NULL的值是什么？

该表达式将被评估为true，因为NULL将被视为任何其他未定义的变量。

> 注意：JavaScript区分大小写，我们在这里使用NULL而不是null。

### 36、代码返回后会怎么样？

```TypeScript

console.log(typeof typeof  1);

```

string

typeof 1将返回“number”，typeof“number”将返回字符串。

### 37、以下代码输出什么？为什么？

```TypeScript

var  b  =  1;

function  outer(){

 var  b  =  2

    function  inner(){

        b++;

        var  b  =  3;

        console.log(b)

    }

    inner();

}

outer();

```

输出到控制台将是“3”。

在这个例子中有三个闭包，每个都有它自己的var b声明。当调用变量时，将按照从本地到全局的顺序检查闭包，直到找到实例。由于内部闭包有自己的b变量，这就是输出。

此外，由于提升内部的代码将被解释如下：

```TypeScript

function  inner  ()  {

    var  b;  // b is undefined

    b++;  // b is NaN

    b  =  3;  // b is 3

    console.log(b);  // output "3"

}
```